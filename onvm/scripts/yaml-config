#!/bin/bash

# This is the library to handle yaml files. The library will allow you
# to load a yaml file and access each member, and also allow you to save
# variables to a new yaml file. The only limitation is that the name of
# yaml variables can not contain string _TTT0LLL_ since that string
# is used as a delimiter in the program. Also the yaml file has to use 2
# spaces as the indention, any spacing other than 2 will cause problems.

parse_yaml() {
    local prefix=$2
    local s
    local w
    local fs
    s='[[:space:]]*'
    w='[a-zA-Z0-9_]*'
    fs="$(echo @|tr @ '\034')"
    sed -ne "s|^\($s\)\($w\)$s:$s\"\(.*\)\"$s\$|\1$fs\2$fs\3|p" \
        -e "s|^\($s\)\($w\)$s[:-]$s\(.*\)$s\$|\1$fs\2$fs\3|p" "$1" |
    awk -F"$fs" '{
    indent = length($1)/2;
    vname[indent] = $2;
    for (i in vname) {if (i > indent) {delete vname[i]}}
        if (length($3) > 0) {
            vn=""; for (i=0; i<indent; i++) {vn=(vn)(vname[i])("_TTT0LLL_")}
            printf("%s%s%s=(\"%s\")\n", "'"$prefix"'",vn, $2, $3);
        }
    }' | sed 's/_TTT0LLL_=/+=/g'
}

parse_flat_yaml() {
    local prefix=$2
    grep -P "^([a-zA-Z0-9_]*\.)+[a-zA-Z0-9_]+:[ ]*.+$" $1 | sort | while read line
    do
        local key; local val
        IFS=':' read -r key val <<< "$line"
        key=${key//./_TTT0LLL_}
        # Strip leading and trailing spaces
        val="$(sed -e 's/[[:space:]]*$//' <<<${val})"
        local cmd="${prefix}${key}='${val}'"
        echo $cmd
    done
}

# Load a yaml file as a set of environment variables.
# Usage:
#   load_yaml 'leap_' '/onvm/conf/nodes.conf.yml'
function load_yaml {
   eval $(parse_yaml $2 $1)
   eval $(parse_flat_yaml $2 $1)
}

# save environments variables with given starting string into a yaml file
# Usage:
#   save_yaml 'leap_' '/etc/test/a_yaml_file.yml' 
function save_yaml {
   echo '---' > $2
   echo '#ES-Install Generated Configurations' >> $2
   set | sed -n -e "/^$1/p" | sort | while read line
   do
      local key; local val
      # Get rid of the prefix
      local newline="${line/$1/}"
      # now split the line by the equal sign into two pieces
      IFS='=' read -r key val <<< "$newline"
      key=${key//_TTT0LLL_/.}
      val="${val%\'}"
      val="${val#\'}"
      echo "${key}: ${val}" >> $2
   done
}

# set environments variable with given value
# Usage:
#   set_yaml_value 'leap_' 'name' 'value'
function set_yaml_value {
   local name=$2
   name=${name//./_TTT0LLL_}
   eval $1$name='$3'
}

# get environments variable with given name
# Usage:
#   get_yaml_value 'leap_' 'name'
function get_yaml_value {
   local name=$2
   name=$1${name//./_TTT0LLL_}
   eval name=\$${name}
   echo $name
}

# delete environments variable with given name
# Usage:
#   del_yaml_value 'leap_' 'name'
# above command will remove an environment variable named leap_name
function del_yaml_value {
   local name=$2
   name=${name//./_TTT0LLL_}
   unset $1$name
}

# clear set of environments varilables starting with the given values
# Usage:
#   del_yaml_values 'leap_' 'name'
# above command will remove all environment variables starts with leap_name
# if leave the second parameter blank, the command will remove all the
# environment variables starts with leap_
function del_yaml_values {
   local name=$2
   name=${name//./_TTT0LLL_}
   list=`set | sed -n -e "/^$1$name/p" | awk -F= '/^\w/ {print $1}' | xargs`
   unset -v $list
}

# get a set of environments varilables starting with the given values
# Usage:
#   get_yaml_values 'leap_' 'name.name1.name2'
# above command will remove all environment variables starts with leap_name
# if leave the second parameter blank, the command will remove all the
# environment variables starts with leap_
function get_yaml_values {
   local name=$2
   name=${name//./_TTT0LLL_}
   list=`set | sed -n -e "/^$1$name/p" | awk -F= '/^\w/ {print $1}' | xargs`
   local val
   eval val=\$\{$list[@]\}
   echo $val
}
